============================= 
파트 1 : 자, 시작합시다 
============================= 

소개 
-------- 

조금 전의 일이지만,`Twisted`_의`메일 링리스트 <http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python>`_에 "Twisted 입문용 문서는 죽음의 후치에 있구나 '라는 취지의`게시물 <http://twistedmatrix.com/pipermail/twisted-python/2009-May/019706.html>`_이있었습니다. 완전히 가지고 그런 것은 아닙니다. Twisted와 Python에서의 비동기 프로그래밍 입문 용 문서에 대해서는 정반대일지도 모릅니다. 만약 시간이 없거나 끈기 않은 경우에, 이것은 당신이 찾고있는 입문용 문서가 없습니다. 

.. _Twisted : http://twistedmatrix.com/ 

당신이 비동기 프로그래밍의 초심자라면 빠른 입문용 문서에 구리 아우 것은 아무튼 무리 일 것이다라고 생각합니다. 적어도 당신은 천재가 아니다 것이고. 나는 몇 년 Twisted를 사용 와서 어떻게 자신이 먼저 (천천히) 배우고, 무엇이 어려운지를 생각해 오는 중에 몇을 해낼 중요한 것이 아니라 비동기 코드를 작성 이해 위해 요구되는 "정신 모델"의 획득이 중요하다는 결론에 도달했습니다. Twisted 소스 코드의 대부분은 분명하고 확고 작성하고 온라인으로 읽을 수있는 문서도 양질입니다. 대부분의 프리 소프트웨어를 기준으로 한 경우입니다. 그러나 정신 모델이 없으면 Twisted 코드 기반과 Twisted를 사용하는 코드를 읽을 수 있으며 대량의 문서를 읽을 수조차 당황하거나 귀찮게 수 밖에 없을 것입니다. 

따라서이 입문의 첫 번째 파트에서는 ​​독자가 모델을 이해하기 쉽도록 배려하고 Twisted 기능 소개는 뒷전으로하고 있습니다. 사실 처음에는 Twisted을 전혀 사용하지 않고 그 대신 어떻게 비동기 시스템이 작동하는 방법을 설명하기위한 간단한 Python 프로그램을 사용합니다. 그리고 Twisted를 사용하게되면 일상적인 프로그래밍에서 일반적으로 사용하지 않는 것이다 낮은 수준 부분에서 시작 것입니다. Twisted는 고도로 추상화 된 시스템에서 문제를 해결 때 도약을 이끌어줍니다. 그러나 Twisted을 배우고 있거나 Twisted가 실제로 어떻게 작동하는지 이해하려고 할 때조차도 많은 추상화 된 수준은 문제를 일으 킵니다. 그러므로 기본적인 것부터 시작해 안쪽에서 바깥쪽으로 이야기를 진행시켜 나갑시다. 

일단 멘탈 모델을 획득하면`Twisted 문서 <http://twistedmatrix.com/trac/wiki/Documentation>`_를 읽고`소스 코드를 바라 보는 <http://twistedmatrix.com/trac/browser>` _ 것은 훨씬 쉽게 느껴진다 고 생각합니다. 시작하자. 

모델 
------ 
동기화 모델과의 차이를 명확하게하기 위해 (바라건대) 친숙한 두 모델에서 시작합시다. 그림에 보면 프로그램을 완료하기 위해 실행 없어서는 안 개념적으로 독립적 인 세 개의 작업으로 구성된 프로그램을 상상할 수 있군요. 이러한 작업은 나중에 구체적으로하지만 지금은 프로그램이 그들을 작동시켜야한다 것을 제외하고는 아무것도 언급하지 않습니다. 나가 "작업"이라는 단어를 "실행 될 필요가있는 무엇인가 '라는 비 기술적 인 의미에서 사용하고있는 점에 유의하십시오. 

첫 번째 모델은 친숙한 단일 스레드 동기화 모델입니다. 아래의 그림 1을보세요. 

.. _figure1 : 

.. figure :: images / p01_sync.png 

    그림 1 : 동기화 모델 


이것은 프로그래밍에서 가장 간단한 형태입니다. 각각의 작업은 한 번에 하나씩 밖에 실행되지 않고 다른 작업이 시작되기 전에있는 작업은 완전히 종료합니다. 작업이 항상 정해진 순서대로 실행된다면 나중에 실행되는 작업의 구현은 사전에 수행되는 모든 작업은 오류없이 종료하고 그 출력을 사용할 수있는, 가정 수 있습니다. 논리적으로 매우 단순화됩니다. 

동기화 모델과 대조적 인 것들로 그림 2 스레드 모델을들 수 있습니다. 

.. _figure2 : 

.. figure :: images / p01_threaded.png 

    그림 2 : 스레딩 모델 

이 모델에서는 각각의 작업은 별도의 쓰레드 제어 하에서 실행됩니다. 스레드는 운영 시스템에 의해 관리되고 여러 프로세서 및 코어를 가지는 시스템에서는 진정한 병렬로 실행되는 단일 프로세서 시스템에서는 우스꽝하고 동일시 실행됩니다. 스레드 모델에서 중요한 점은 실행의 자세한 내용은 OS에 의해 제어되기 때문에, 프로그래머는 동시에 실행 될지도 모른다 일련의 독립적 인 명령이라는 관점에서 보면된다라는 것입니다. 다이어그램은 간단하지만 스레드가 서로 협조해야하므로 실제 스레드 프로그래밍은 매우 복잡하게 될 수 있습니다. 스레드 간 통신 및 스레드의 협조는 진일보 한 프로그래밍의 주제이며, 제대로 사용하는 것은 어렵습니다. 

여러 스레드 대신 여러 프로세스를 사용하여 평행을 구현하는 프로그램도 있습니다. 프로그래밍의 자세한 내용은 다르지만 우리의 목적에서 보면 그림 2에 표시된 것과 같은 모델입니다. 

드디어 그림 3에서 비동기 모델을 소개합니다.

.. _figure3:

.. figure:: images/p01_async.png

그림 3 : 비동기 모델 

이 모델은 작업 우스꽝되지만 단일 스레드로 제어됩니다. 프로그래머의 작업이 실행되어 다른 작업이 실행되지 않은 것을 알고 있기 때문에 스레드의 경우보다 간단합니다. 단일 프로세서 시스템에서 스레드 프로그램도 마찬가지로 작동하지만 여러 프로세서 시스템에 이식 할 때 프로그램이 잘못 작동하지 않도록 스레드를 사용하는 프로그래머는 그림 3 대신 그림 2의 관점에서 생각해야 입니다. 그러나 단일 스레드 비동기 시스템은 항상 우스꽝되어 실행되는 것입니다. 비록 여러 프로세서 시스템이었다해도. 

비동기와 스레드 모델은 또 다른 차이점이 있습니다. 스레드 시스템에서 스레드를 일시 정지시켜 다른 스레드를 실행하는 결정은 프로그래머가 제어하는 범주는 없습니다. 오히려 운영 체제의 일이고, 프로그래머는 거의 모든 경우에서 스레드는 일시 중지하고 다른 스레드로 대체 생각하지 않으면 안됩니다. 이에 대해 비동기 모델에서는 명시 적으로 다른 작업에 제어를 양보까지 작업은 계속 실행 것입니다. 이것은 스레드의 경우에서 더욱 단순화합니다. 

동일한 시스템에서 비동기와 스레드의 두 모델을 혼합하거나 함께 사용할 수도 있다는 점에 유의하십시오. 그러나이 문서의 대부분은 단일 스레드 제어에서 근면 비동기 시스템을 취급합니다. 

동기 
---- 
지금까지 스레드 모델보다 비동기 모델이 단순하다는 것을보고 왔습니다. 단일 명령 처리 흐름 밖에없고, 작업이 언제든지 중지시킬 수있는 것이 아니라 명시 적으로 제어를 양보 때문입니다. 그러나 비동기 모델은 동기화 것에 비해 분명히 복잡합니다. 프로그래머는 각각의 작업을 간헐적으로 수행되는 더 작은 단계의 흐름으로 구성하지 않으면 안됩니다. 그리고 만일 작업이 다른 작업의 출력을 사용하고 있으면 그 의존하는 작업은 모든 것을 정리 한 것이 아니라 일련의 조각이나 부분으로 입력을 받아 기술 해 두지 않으면 안됩니다 . 실제 병행하지 않으므로 비동기 프로그램은 동기화 것만큼이나 길게 실행되는 것입니다. 어쩌면 비동기 프로그램이 빈약 한`参照の局所性 <http://en.wikipedia.org/wiki/Locality_of_reference>`_을 드러내는 것처럼, 더 긴 실행 시간이 될 것입니다. 

그럼, 왜 비동기 모델을 사용하는 것을 선택할까요? 여기에는 적어도 두 가지 이유가 있습니다. 첫째, 하나 이상의 태스크가 인간 상호 작용을 맡고 있으면 작업을 우스꽝 분할함으로써 시스템은 다른 작업을 "백그라운드"에서 작동시키면서 사용자의 입력을 기다린다 수 있습니다. 시스템은 백그라운드 작업을 빠르게 수행하지 않을지도 모르지만, 인간이 사용하는 분에는 기쁜 것입니다. 

그러나 비동기 시스템이 동기화보다 간단하게 잘 작동하려면 때로는 극적으로 모든 작업을 전체적으로 빠르게 실행한다는 의미이지만, 조건이 있습니다. 이 조건은 그림 4에 나타내도록 작업이 강제로 기다리게되거나 차단 될 때 발생합니다. 

.. _figure4 : 

.. figure :: images / p01_block.png 

    그림 4 : 동기화 프로그래밍 차단 

이 그림에서 회색 부분이 특정 작업이 기다리고있어 (차단하고) 진척이없는 기간을 나타냅니다. 왜 작업이 차단되는 것입니까? 가장 일반적인 이유는 입출력 (I / O) 조작이나 외부 기기에 대한 데이터 전송을 기다리는 것입니다. 전형적인 CPU는 디스크 나 네트워크에서 사용할 수있는 것에 대해 비교가되지 않을 정도로 빠른 속도로 데이터를 전송할 수 있습니다. 즉, 많은 입출력을 수반하는 동기화 프로그램은 디스크 나 네트워크가 따라 잡을 때까지 많은 시간을 차단되게 될 것입니다. 이러한 동기화 프로그램은 그 이유로 차단 프로그램이라고도합니다. 

그림 4 (차단 프로그램)은 조금 그림 3 (비동기 프로그램)처럼도 보이는 것에주의하십시오. 우연의 일치는 없습니다. 비동기 모델 뒤에 기본적인 아이디어는 동기화 프로그램에서 일반적으로 차단하는 것이다 작업에 직면했을 때 진행되는 다른 작업을 대신 수행 할 수있을 것입니다. 비동기 프로그램은 진행되는 작업이 아무것도 없을 때 차단 뿐이므로, 블로킹 프로그램이라고합니다. 또한, 작업에서 다른 작업에 스위치는 맨 처음 작업이 종료되거나 차단해야하는 상황에 이르렀는지 중 하나에 대응하고 있습니다. 잠재적으로 대량의 블로킹 작업이 있으면 대충해서 개별 작업에 소요되는 실제 시간은 같은 정도이지만 전체적으로 대기 시간이 짧아지기 때문에 비동기 프로그램은 동기화 것에 비해 크게 성능을 향상시킬 수 있습니다. 

동기화 모델과 비교하여 비동기 모델이 성능을 발휘하는 것은 다음과 같은 경우입니다. 

# 대량의 작업이 거의 항상 적어도 하나는 진행되는 작업이있을 때. 
# 태스크가 대량의 입출력을 심판 다른 작업을 수행 할 수 있을지도 모르다 동기화 프로그램을 차단 해 대량으로 시간을 낭비시켜 버리는 때. 
#. 작업이 서로 독립적으로 작업 간의 통신이 거의 필요 없을 때. (따라서있는 작업이 다른 작업을 기다릴 필요 없다) 

이러한 조건은 클라이언트 서버 환경에서 거의 완전하게 전형적인 고부하의 네트워크 서버 (Web 서버 등)의 수를 나타냅니다. 각각의 작업은 요청을 받고 이에 응답 쓰기 같은 입출력을 수반 클라이언트의 요청을 의미합니다. 그리고 클라이언트의 요청 (대부분이로드)는 대개 독립하고 있습니다. 따라서 네트워크 서버의 구현은 비동기 모델에 가장 적용하기 쉽고, 따라서 Twisted은 뭐니 뭐니해도 네트워크 라이브러리입니다. 

다음은 
---- 
이제 파트 1은 끝입니다. ": doc :`p02`"는 일부 네트워크 프로그램을 씁니다. 차단 및 비 차단 모두에서 최대한 쉽게 (Twisted를 사용하지 않고) 비동기 Python 프로그램이 실제로 작동하는 분위기를 잡아달라고 때문입니다.

..
    <H2>Part 1: In Which We Begin at the Beginning
    <H3>Preface
    Someone recently <A href="http://twistedmatrix.com/pipermail/twisted-python/2009-May/019706.html">posted</A> to the <A href="http://twistedmatrix.com/">Twisted</A> <A href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing list</A> asking for something like the "Twisted introduction for people on a deadline". Full disclosure: this isn't it. On the spectrum of introductions to Twisted and asynchronous programming in Python, it may be on the exact opposite end. So if you don't have any time, or any patience, this isn't the introduction you are looking for.
    However, I also believe that if you are new to asynchronous programming, a quick introduction is simply not possible, at least if you are not a genius. I've used Twisted successfully for a number of years and having thought about how I initially learned it (slowly), and what I found difficult, I've come to the conclusion that much of the challenge does not stem from Twisted per se, but rather in the acquisition of the "mental model" required to write and understand asynchronous code. Most of the Twisted source code is clear and well written, and the online documentation is good, at least by the standards of most free software. But without that mental model, reading the Twisted codebase, or code that uses Twisted, or even much of the documentation, will result in confusion and headache.
    So the first parts of this introduction are designed to help you acquire that model and only later on will we introduce the features of Twisted. In fact, we will start without using Twisted at all, instead using simple Python programs to illustrate how an asynchronous system works. And once we get into Twisted, we will begin with very low-level aspects that you would not normally use in day-to-day programming. Twisted is a highly abstracted system and this gives you tremendous leverage when you use it to solve problems. But when you are learning Twisted, and particularly when you are trying to understand how Twisted actually works, the many levels of abstraction can cause troubles. So we will go from the inside-out, starting with the basics.
    And once you have the mental model in place, I think you will find reading the <A href="http://twistedmatrix.com/trac/wiki/Documentation">Twisted documentation</A>, or just <A href="http://twistedmatrix.com/trac/browser">browsing the source code</A>, to be much easier. So let's begin.
    <H3>The Models
    We will start by reviewing two (hopefully) familiar models in order to contrast them with the asynchronous model. By way of illustration we will imagine a program that consists of three conceptually distinct tasks which must be performed to complete the program. We will make these tasks more concrete later on, but for now we won't say anything about them except the program must perform them. Note I am using "task" in the non-technical sense of "something that needs to be done".
    The first model we will look at is the familiar single-threaded synchronous model, in Figure 1 below:<A name="figure1"></A>
    <DIV id="attachment_2026" class="wp-caption aligncenter" style="width: 146px"><A href="./part1_files/sync.png"><IMG class="size-full wp-image-2026" title="Figure 1: the synchronous model" src="./part1_files/sync.png" alt="Figure 1: the synchronous model" width="136" height="361"></A><P class="wp-caption-text">Figure 1: the synchronous model</DIV>
    This is the simplest style of programming. Each task is perfomed one at a time, with one finishing completely before another is started. And if the tasks are always performed in a definite order, the implementation of a later task can assume that all earlier tasks have finished without errors, with all their output available for use&nbsp;— a definite simplification in logic.
    We can contrast the synchronous model with another one, the threaded model illustrated in Figure 2:
    <DIV id="attachment_2028" class="wp-caption aligncenter" style="width: 388px"><A href="./part1_files/threaded.png"><IMG class="size-full wp-image-2028" title="Figure 2: the threaded model" src="./part1_files/threaded.png" alt="Figure 2: the threaded model" width="378" height="120"></A><P class="wp-caption-text">Figure 2: the threaded model</DIV>
    In this model, each task is performed in a separate thread of control. The threads are managed by the operating system and may, on a system with multiple processors or multiple cores, run truly concurrently, or may be interleaved together on a single processor. The point is, in the threaded model the details of execution are handled by the OS and the programmer simply thinks in terms of independent instruction streams which may run simultaneously. Although the diagram is simple, in practice threaded programs can be quite complex because of the need for threads to coordinate with one another. Thread communication and coordination is an advanced programming topic and can be difficult to get right.
    Some programs implement parallelism using multiple processes instead of multiple threads. Although the programming details are different, for our purposes it is the same model as in Figure 2.
    Now we can introduce the asynchronous model in Figure 3:<A name="figure3"></A>
    <DIV id="attachment_2030" class="wp-caption aligncenter" style="width: 186px"><A href="./part1_files/async.png"><IMG class="size-full wp-image-2030" title="Figure 3: the asynchronous model" src="./part1_files/async.png" alt="Figure 3: the asynchronous model" width="176" height="361"></A><P class="wp-caption-text">Figure 3: the asynchronous model</DIV>
    In this model, the tasks are interleaved with one another, but in a single thread of control. This is simpler than the threaded case because the programmer always knows that when one task is executing, another task is not. Although in a single-processor system a threaded program will also execute in an interleaved pattern, a programmer using threads should still think in terms of Figure 2, not Figure 3, lest the program work incorrectly when moved to a multi-processor system. But a single-threaded asynchronous system will always execute with interleaving, even on a multi-processor system.
    There is another difference between the asynchronous and threaded models. In a threaded system the decision to suspend one thread and execute another is largely outside of the programmer's control. Rather, it is under the control of the operating system, and the programmer must assume that a thread may be suspended and replaced with another at almost any time. In contrast, under the asynchronous model a task will continue to run until it explicitly relinquishes control to other tasks. This is a further simplification from the threaded case.
    <P style="padding-left: 30px;">Note that it is possible to mix the asynchronous and threaded models and use both in the same system. But for most of this introduction, we will stick to "plain vanilla" asynchronous systems with one thread of control.
    <H3>The Motivation
    We've seen that the asynchronous model is simpler than the threaded one because there is a single instruction stream and tasks explicitly relinquish control instead of being suspended arbitrarily. But the asynchronous model is clearly more complex than the synchronous case. The programmer must organize each task as a sequence of smaller steps that execute intermittently. And if one task uses the output of another, the dependent task must be written to accept its input as a series of bits and pieces instead of all together. Since there is no actual parallelism, it appears from our diagrams that an asynchronous program will take just as long to execute as a synchronous one, perhaps longer as the asynchronous program might exhibit poorer <A href="http://en.wikipedia.org/wiki/Locality_of_reference">locality of reference</A>.
    So why would you choose to use the asynchronous model? There are at least two reasons. First, if one or more of the tasks are responsible for implementing an interface for a human being, then by interleaving the tasks together the system can remain responsive to user input while still performing other work in the "background". So while the background tasks may not execute any faster, the system will be more pleasant for the person using it.
    However, there is a condition under which an asynchronous system will simply outperform a synchronous one, sometimes dramatically so, in the sense of performing all of its tasks in an overall shorter time. This condition holds when tasks are forced to wait, or <EM>block</EM>, as illustrated in Figure 4:<A name="figure4"></A>
    <DIV id="attachment_2032" class="wp-caption aligncenter" style="width: 267px"><A href="./part1_files/block.png"><IMG class="size-full wp-image-2032" title="Figure 4: blocking in a synchronous program" src="./part1_files/block.png" alt="Figure 4: blocking in a synchronous program" width="257" height="361"></A><P class="wp-caption-text">Figure 4: blocking in a synchronous program</DIV>
    In the figure, the gray sections represent periods of time when a particular task is waiting (blocking) and thus cannot make any progress. Why would a task be blocked? The most typical reason is that it is waiting to perform I/O, to transfer data to or from an external device. A typical CPU can handle data transfer rates that are orders of magnitude faster than a disk or a network link is capable of sustaining. Thus, a synchronous program that is doing lots of I/O will spend much of its time blocked while a disk or network catches up. Such a synchronous program is also called a blocking program for that reason.
    Notice that Figure 4, a blocking program, looks a bit like Figure 3, an asynchronous program. This is not a coincidence. The fundamental idea behind the asynchronous model is that an asynchronous program, when faced with a task that would normally block in a synchronous program, will instead execute some other task that can still make progress. So an asynchronous program only "blocks" when no task can make progress and is thus called a non-blocking program. And each switch from one task to another corresponds to the first task either finishing, or coming to a point where it would have to block. With a large number of potentially blocking tasks, an asynchronous program can outperform a synchronous one by spending less overall time waiting, while devoting a roughly equal amount of time to real work on the individual tasks.
    Compared to the synchronous model, the asynchronous model performs best when:
    <OL>
    * There are a large number of tasks so there is likely always at least one task that can make progress.
    * The tasks perform lots of I/O, causing a synchronous program to waste lots of time blocking when other tasks could be running.
    * The tasks are largely independent from one another so there is little need for inter-task communication (and thus for one task to wait upon another).
    </OL>
    These conditions almost perfectly characterize a typical busy network server (like a web server) in a client-server environment. Each task represents one client request with I/O in the form of receiving the request and sending the reply. And client requests (being mostly reads) are largely independent. So a network server implementation is a prime candidate for the asynchronous model and this is why Twisted is first and foremost a networking library.
    <H3>Onward and Upward
    This is the end of Part 1. In <A href="http://krondo.com/blog/?p=1247">Part 2</A>, we will write some network programs, both blocking and non-blocking, as simply as possible (without using Twisted), to get a feel for how an asynchronous Python program actually works.
